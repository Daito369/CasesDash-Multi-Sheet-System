/**
 * Report Generator - Advanced Report Generation Engine
 * Handles PDF/Excel output, custom reports, and scheduled delivery
 * 
 * @author Roo
 * @version 1.0
 * @since 2025-05-25
 */

/**
 * Report Generator Configuration
 */
const REPORT_CONFIG = {
  // Report storage and templates
  TEMPLATES_SHEET_NAME: 'ReportTemplates',
  REPORTS_HISTORY_SHEET_NAME: 'ReportsHistory',
  SCHEDULED_REPORTS_SHEET_NAME: 'ScheduledReports',
  
  // Output formats
  SUPPORTED_FORMATS: ['PDF', 'Excel', 'CSV', 'HTML'],
  
  // Report types
  REPORT_TYPES: {
    'statistics': 'Statistics Report',
    'case_summary': 'Case Summary Report',
    'performance': 'Performance Report',
    'trend_analysis': 'Trend Analysis Report',
    'custom': 'Custom Report'
  },
  
  // Delivery channels
  DELIVERY_CHANNELS: {
    'email': 'Email Delivery',
    'drive': 'Google Drive',
    'download': 'Direct Download'
  },
  
  // Report styling
  DEFAULT_STYLES: {
    headerColor: '#1976d2',
    accentColor: '#2196f3',
    textColor: '#333333',
    backgroundColor: '#ffffff',
    fontFamily: 'Arial',
    fontSize: 11
  }
};

/**
 * Main Report Generator Class
 */
class ReportGenerator {
  constructor() {
    this.errorHandler = new ErrorHandler();
    this.configManager = new ConfigManager();
    this.performanceManager = new PerformanceManager();
    
    this.templatesCache = null;
    this.lastCacheUpdate = null;
  }

  /**
   * Initialize report generator
   */
  initialize() {
    try {
      console.log('初期化中: レポートジェネレーター...');
      
      this.setupReportSheets();
      this.loadReportTemplates();
      this.setupScheduledReports();
      
      console.log('✅ レポートジェネレーターが正常に初期化されました');
      return { success: true };
      
    } catch (error) {
      console.error('❌ レポートジェネレーターの初期化に失敗:', error);
      return this.errorHandler.handleError(error, 'report_generator_initialization');
    }
  }

  /**
   * Setup report-related sheets
   */
  setupReportSheets() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    
    // Report Templates sheet
    let templatesSheet = ss.getSheetByName(REPORT_CONFIG.TEMPLATES_SHEET_NAME);
    if (!templatesSheet) {
      templatesSheet = ss.insertSheet(REPORT_CONFIG.TEMPLATES_SHEET_NAME);
      const headers = [
        'Template ID', 'Template Name', 'Report Type', 'Description',
        'Data Sources', 'Format Options', 'Styling', 'Sections',
        'Created Date', 'Created By', 'Last Modified', 'Is Active'
      ];
      templatesSheet.getRange(1, 1, 1, headers.length).setValues([headers]);
      templatesSheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
    }
    
    // Reports History sheet
    let historySheet = ss.getSheetByName(REPORT_CONFIG.REPORTS_HISTORY_SHEET_NAME);
    if (!historySheet) {
      historySheet = ss.insertSheet(REPORT_CONFIG.REPORTS_HISTORY_SHEET_NAME);
      const headers = [
        'Report ID', 'Template ID', 'Report Name', 'Generated Date',
        'Generated By', 'Format', 'File Size', 'Delivery Method',
        'Recipients', 'Status', 'File Path', 'Notes'
      ];
      historySheet.getRange(1, 1, 1, headers.length).setValues([headers]);
      historySheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
    }
    
    // Scheduled Reports sheet
    let scheduledSheet = ss.getSheetByName(REPORT_CONFIG.SCHEDULED_REPORTS_SHEET_NAME);
    if (!scheduledSheet) {
      scheduledSheet = ss.insertSheet(REPORT_CONFIG.SCHEDULED_REPORTS_SHEET_NAME);
      const headers = [
        'Schedule ID', 'Template ID', 'Schedule Name', 'Frequency',
        'Schedule Time', 'Recipients', 'Format', 'Delivery Method',
        'Last Run', 'Next Run', 'Is Active', 'Created By'
      ];
      scheduledSheet.getRange(1, 1, 1, headers.length).setValues([headers]);
      scheduledSheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
    }
  }

  /**
   * Load report templates from sheet
   */
  loadReportTemplates() {
    try {
      const cacheKey = 'report_templates_cache';
      const cached = this.configManager.getFromCache(cacheKey);
      
      if (cached && this.isCacheValid()) {
        this.templatesCache = cached;
        return;
      }
      
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const templatesSheet = ss.getSheetByName(REPORT_CONFIG.TEMPLATES_SHEET_NAME);
      
      if (!templatesSheet) {
        throw new Error('Report templates sheet not found');
      }
      
      const data = templatesSheet.getDataRange().getValues();
      const headers = data[0];
      const templates = [];
      
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        if (row[0]) { // Template ID exists
          const template = {};
          headers.forEach((header, index) => {
            template[header] = row[index];
          });
          
          // Parse JSON fields
          try {
            template['Data Sources'] = JSON.parse(template['Data Sources'] || '[]');
            template['Format Options'] = JSON.parse(template['Format Options'] || '{}');
            template['Styling'] = JSON.parse(template['Styling'] || '{}');
            template['Sections'] = JSON.parse(template['Sections'] || '[]');
          } catch (parseError) {
            console.warn(`Invalid JSON in template ${template['Template ID']}:`, parseError);
          }
          
          templates.push(template);
        }
      }
      
      this.templatesCache = templates.filter(template => template['Is Active'] === true);
      this.lastCacheUpdate = new Date();
      
      // Cache for 30 minutes
      this.configManager.setCache(cacheKey, this.templatesCache, 1800);
      
      console.log(`✅ ${this.templatesCache.length} 個のレポートテンプレートを読み込みました`);
      
    } catch (error) {
      console.error('❌ レポートテンプレートの読み込みに失敗:', error);
      this.templatesCache = [];
      throw error;
    }
  }

  /**
   * Generate report based on template and parameters
   * @param {string} templateId - Template ID
   * @param {Object} parameters - Report parameters
   * @param {string} format - Output format (PDF, Excel, CSV, HTML)
   * @param {Object} options - Additional options
   */
  async generateReport(templateId, parameters, format, options = {}) {
    try {
      console.log(`レポート生成開始: Template ${templateId}, Format ${format}`);
      
      const startTime = new Date();
      
      // Load template
      const template = this.getTemplate(templateId);
      if (!template) {
        throw new Error(`Template not found: ${templateId}`);
      }
      
      // Gather data
      const reportData = await this.gatherReportData(template, parameters);
      
      // Generate report based on format
      let reportResult;
      switch (format.toUpperCase()) {
        case 'PDF':
          reportResult = await this.generatePDFReport(template, reportData, options);
          break;
        case 'EXCEL':
          reportResult = await this.generateExcelReport(template, reportData, options);
          break;
        case 'CSV':
          reportResult = await this.generateCSVReport(template, reportData, options);
          break;
        case 'HTML':
          reportResult = await this.generateHTMLReport(template, reportData, options);
          break;
        default:
          throw new Error(`Unsupported format: ${format}`);
      }
      
      // Log report generation
      const reportId = Utilities.getUuid();
      this.logReportGeneration(reportId, template, reportResult, format, options);
      
      const endTime = new Date();
      const generationTime = endTime - startTime;
      
      console.log(`✅ レポート生成完了: ${generationTime}ms`);
      
      return {
        success: true,
        reportId: reportId,
        data: reportResult,
        generationTime: generationTime
      };
      
    } catch (error) {
      console.error('❌ レポート生成に失敗:', error);
      return this.errorHandler.handleError(error, 'report_generation');
    }
  }

  /**
   * Generate PDF report
   */
  async generatePDFReport(template, data, options) {
    try {
      // Create HTML content
      const htmlContent = this.generateHTMLContent(template, data, options);
      
      // Convert HTML to PDF using Google Apps Script's HTML service
      const htmlOutput = HtmlService.createHtmlOutput(htmlContent);
      htmlOutput.setTitle(template['Template Name']);
      
      // For actual PDF generation, we would need to use a different approach
      // as GAS doesn't directly support HTML to PDF conversion
      // This is a simplified implementation
      
      const blob = Utilities.newBlob(htmlContent, 'text/html', `${template['Template Name']}.html`);
      
      // In a real implementation, you might:
      // 1. Use Google Docs API to create a document and export as PDF
      // 2. Use a third-party service for HTML to PDF conversion
      // 3. Create the PDF using Google Slides API
      
      return {
        format: 'PDF',
        blob: blob,
        fileName: `${template['Template Name']}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmmss')}.pdf`,
        size: blob.getBytes().length
      };
      
    } catch (error) {
      console.error('PDF生成エラー:', error);
      throw error;
    }
  }

  /**
   * Generate Excel report
   */
  async generateExcelReport(template, data, options) {
    try {
      // Create new spreadsheet
      const reportSpreadsheet = SpreadsheetApp.create(`${template['Template Name']}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmmss')}`);
      
      // Generate sections
      for (let i = 0; i < template.Sections.length; i++) {
        const section = template.Sections[i];
        const sheetName = section.name || `Section ${i + 1}`;
        
        let sheet;
        if (i === 0) {
          sheet = reportSpreadsheet.getActiveSheet();
          sheet.setName(sheetName);
        } else {
          sheet = reportSpreadsheet.insertSheet(sheetName);
        }
        
        await this.generateExcelSection(sheet, section, data, template);
      }
      
      // Apply styling
      this.applyExcelStyling(reportSpreadsheet, template.Styling);
      
      // Convert to blob for download
      const blob = reportSpreadsheet.getBlob();
      
      // Clean up temporary spreadsheet
      DriveApp.getFileById(reportSpreadsheet.getId()).setTrashed(true);
      
      return {
        format: 'Excel',
        blob: blob,
        fileName: `${template['Template Name']}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmmss')}.xlsx`,
        size: blob.getBytes().length
      };
      
    } catch (error) {
      console.error('Excel生成エラー:', error);
      throw error;
    }
  }

  /**
   * Generate CSV report
   */
  async generateCSVReport(template, data, options) {
    try {
      let csvContent = '';
      
      // Generate CSV for each data section
      for (const section of template.Sections) {
        if (section.type === 'table' && data[section.dataSource]) {
          const tableData = data[section.dataSource];
          
          // Add section header
          if (section.name) {
            csvContent += `"${section.name}"\n\n`;
          }
          
          // Add table headers
          if (tableData.length > 0) {
            const headers = Object.keys(tableData[0]);
            csvContent += headers.map(h => `"${h}"`).join(',') + '\n';
            
            // Add data rows
            for (const row of tableData) {
              const values = headers.map(h => `"${String(row[h] || '').replace(/"/g, '""')}"`);
              csvContent += values.join(',') + '\n';
            }
          }
          
          csvContent += '\n';
        }
      }
      
      const blob = Utilities.newBlob(csvContent, 'text/csv', `${template['Template Name']}.csv`);
      
      return {
        format: 'CSV',
        blob: blob,
        fileName: `${template['Template Name']}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmmss')}.csv`,
        size: blob.getBytes().length
      };
      
    } catch (error) {
      console.error('CSV生成エラー:', error);
      throw error;
    }
  }

  /**
   * Generate HTML report
   */
  async generateHTMLReport(template, data, options) {
    try {
      const htmlContent = this.generateHTMLContent(template, data, options);
      const blob = Utilities.newBlob(htmlContent, 'text/html', `${template['Template Name']}.html`);
      
      return {
        format: 'HTML',
        blob: blob,
        content: htmlContent,
        fileName: `${template['Template Name']}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmmss')}.html`,
        size: blob.getBytes().length
      };
      
    } catch (error) {
      console.error('HTML生成エラー:', error);
      throw error;
    }
  }

  /**
   * Generate HTML content for reports
   */
  generateHTMLContent(template, data, options) {
    const styles = { ...REPORT_CONFIG.DEFAULT_STYLES, ...template.Styling };
    
    let html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>${template['Template Name']}</title>
        <style>
          body {
            font-family: ${styles.fontFamily};
            font-size: ${styles.fontSize}pt;
            color: ${styles.textColor};
            background-color: ${styles.backgroundColor};
            margin: 20px;
            line-height: 1.6;
          }
          .header {
            background-color: ${styles.headerColor};
            color: white;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 5px;
          }
          .section {
            margin-bottom: 30px;
            page-break-inside: avoid;
          }
          .section-title {
            background-color: ${styles.accentColor};
            color: white;
            padding: 10px;
            font-weight: bold;
            margin-bottom: 15px;
            border-radius: 3px;
          }
          table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
          }
          th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
          }
          th {
            background-color: ${styles.accentColor};
            color: white;
            font-weight: bold;
          }
          tr:nth-child(even) {
            background-color: #f9f9f9;
          }
          .chart-placeholder {
            width: 100%;
            height: 300px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
          }
          .summary-stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
          }
          .stat-card {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
            min-width: 120px;
          }
          .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: ${styles.headerColor};
          }
          .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
          }
          .footer {
            margin-top: 50px;
            padding: 20px;
            border-top: 1px solid #ddd;
            font-size: 10px;
            color: #666;
            text-align: center;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>${template['Template Name']}</h1>
          <p>生成日時: ${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy年MM月dd日 HH:mm:ss')}</p>
        </div>
    `;
    
    // Generate sections
    for (const section of template.Sections) {
      html += this.generateHTMLSection(section, data);
    }
    
    // Add footer
    html += `
        <div class="footer">
          <p>このレポートは CasesDash システムによって自動生成されました。</p>
          <p>生成者: ${Session.getActiveUser().getEmail()}</p>
        </div>
      </body>
      </html>
    `;
    
    return html;
  }

  /**
   * Generate HTML section
   */
  generateHTMLSection(section, data) {
    let html = `<div class="section">`;
    
    if (section.name) {
      html += `<div class="section-title">${section.name}</div>`;
    }
    
    switch (section.type) {
      case 'table':
        html += this.generateHTMLTable(section, data);
        break;
      case 'chart':
        html += this.generateHTMLChart(section, data);
        break;
      case 'summary':
        html += this.generateHTMLSummary(section, data);
        break;
      case 'text':
        html += this.generateHTMLText(section, data);
        break;
      default:
        html += `<p>Unknown section type: ${section.type}</p>`;
    }
    
    html += `</div>`;
    return html;
  }

  /**
   * Generate HTML table
   */
  generateHTMLTable(section, data) {
    const tableData = data[section.dataSource];
    if (!tableData || !Array.isArray(tableData) || tableData.length === 0) {
      return '<p>データがありません。</p>';
    }
    
    let html = '<table>';
    
    // Headers
    const headers = section.columns || Object.keys(tableData[0]);
    html += '<thead><tr>';
    for (const header of headers) {
      html += `<th>${header}</th>`;
    }
    html += '</tr></thead>';
    
    // Data rows
    html += '<tbody>';
    for (const row of tableData) {
      html += '<tr>';
      for (const header of headers) {
        const value = row[header] || '';
        html += `<td>${this.escapeHtml(String(value))}</td>`;
      }
      html += '</tr>';
    }
    html += '</tbody>';
    
    html += '</table>';
    return html;
  }

  /**
   * Generate HTML chart placeholder
   */
  generateHTMLChart(section, data) {
    // For HTML reports, we show a placeholder for charts
    // In a real implementation, you might:
    // 1. Generate chart images using Google Charts API
    // 2. Embed chart data as JSON for client-side rendering
    // 3. Use a charting library that works server-side
    
    return `
      <div class="chart-placeholder">
        <div>
          <h3>${section.chartType || 'Chart'}</h3>
          <p>Chart data: ${section.dataSource}</p>
          <p>Chart placeholder - データ: ${data[section.dataSource] ? data[section.dataSource].length : 0} items</p>
        </div>
      </div>
    `;
  }

  /**
   * Generate HTML summary
   */
  generateHTMLSummary(section, data) {
    const summaryData = data[section.dataSource];
    if (!summaryData) {
      return '<p>サマリーデータがありません。</p>';
    }
    
    let html = '<div class="summary-stats">';
    
    for (const [key, value] of Object.entries(summaryData)) {
      html += `
        <div class="stat-card">
          <div class="stat-value">${value}</div>
          <div class="stat-label">${key}</div>
        </div>
      `;
    }
    
    html += '</div>';
    return html;
  }

  /**
   * Generate HTML text
   */
  generateHTMLText(section, data) {
    let text = section.content || '';
    
    // Replace placeholders with data
    if (section.dataSource && data[section.dataSource]) {
      const sectionData = data[section.dataSource];
      Object.keys(sectionData).forEach(key => {
        const placeholder = `{${key}}`;
        text = text.replace(new RegExp(placeholder, 'g'), sectionData[key] || '');
      });
    }
    
    return `<div>${text}</div>`;
  }

  /**
   * Gather report data based on template data sources
   */
  async gatherReportData(template, parameters) {
    const data = {};
    
    for (const dataSource of template['Data Sources']) {
      try {
        switch (dataSource.type) {
          case 'cases':
            data[dataSource.name] = await this.getCasesData(dataSource, parameters);
            break;
          case 'statistics':
            data[dataSource.name] = await this.getStatisticsData(dataSource, parameters);
            break;
          case 'performance':
            data[dataSource.name] = await this.getPerformanceData(dataSource, parameters);
            break;
          case 'custom_query':
            data[dataSource.name] = await this.executeCustomQuery(dataSource, parameters);
            break;
          default:
            console.warn(`Unknown data source type: ${dataSource.type}`);
        }
      } catch (error) {
        console.error(`Failed to gather data for ${dataSource.name}:`, error);
        data[dataSource.name] = [];
      }
    }
    
    return data;
  }

  /**
   * Get cases data for report
   */
  async getCasesData(dataSource, parameters) {
    const caseModel = new CaseModel();
    const filters = { ...dataSource.filters, ...parameters.filters };
    return caseModel.getCases(filters);
  }

  /**
   * Get statistics data for report
   */
  async getStatisticsData(dataSource, parameters) {
    // This would integrate with StatisticsManager
    const statisticsData = {
      totalCases: 150,
      resolvedCases: 120,
      avgResponseTime: '4.2 hours',
      satisfactionScore: 8.5
    };
    
    return statisticsData;
  }

  /**
   * Get performance data for report
   */
  async getPerformanceData(dataSource, parameters) {
    // This would integrate with PerformanceManager
    const performanceData = [
      { metric: 'Response Time', current: '4.2h', target: '4.0h', status: 'Behind' },
      { metric: 'Resolution Rate', current: '85%', target: '90%', status: 'Behind' },
      { metric: 'Customer Satisfaction', current: '8.5', target: '9.0', status: 'Behind' }
    ];
    
    return performanceData;
  }

  /**
   * Execute custom query for report data
   */
  async executeCustomQuery(dataSource, parameters) {
    // This would execute custom data queries
    // For now, return placeholder data
    return [];
  }

  /**
   * Generate Excel section
   */
  async generateExcelSection(sheet, section, data, template) {
    let currentRow = 1;
    
    // Section title
    if (section.name) {
      sheet.getRange(currentRow, 1).setValue(section.name);
      sheet.getRange(currentRow, 1).setFontWeight('bold');
      sheet.getRange(currentRow, 1).setFontSize(14);
      currentRow += 2;
    }
    
    switch (section.type) {
      case 'table':
        currentRow = this.generateExcelTable(sheet, section, data, currentRow);
        break;
      case 'summary':
        currentRow = this.generateExcelSummary(sheet, section, data, currentRow);
        break;
      default:
        sheet.getRange(currentRow, 1).setValue(`Section type not supported: ${section.type}`);
        currentRow++;
    }
    
    return currentRow;
  }

  /**
   * Generate Excel table
   */
  generateExcelTable(sheet, section, data, startRow) {
    const tableData = data[section.dataSource];
    if (!tableData || !Array.isArray(tableData) || tableData.length === 0) {
      sheet.getRange(startRow, 1).setValue('データがありません。');
      return startRow + 1;
    }
    
    let currentRow = startRow;
    
    // Headers
    const headers = section.columns || Object.keys(tableData[0]);
    for (let i = 0; i < headers.length; i++) {
      const cell = sheet.getRange(currentRow, i + 1);
      cell.setValue(headers[i]);
      cell.setFontWeight('bold');
      cell.setBackground('#e3f2fd');
    }
    currentRow++;
    
    // Data rows
    for (const row of tableData) {
      for (let i = 0; i < headers.length; i++) {
        const value = row[headers[i]] || '';
        sheet.getRange(currentRow, i + 1).setValue(value);
      }
      currentRow++;
    }
    
    // Auto-resize columns
    for (let i = 1; i <= headers.length; i++) {
      sheet.autoResizeColumn(i);
    }
    
    return currentRow + 1;
  }

  /**
   * Generate Excel summary
   */
  generateExcelSummary(sheet, section, data, startRow) {
    const summaryData = data[section.dataSource];
    if (!summaryData) {
      sheet.getRange(startRow, 1).setValue('サマリーデータがありません。');
      return startRow + 1;
    }
    
    let currentRow = startRow;
    
    // Headers
    sheet.getRange(currentRow, 1).setValue('指標');
    sheet.getRange(currentRow, 2).setValue('値');
    sheet.getRange(currentRow, 1, 1, 2).setFontWeight('bold');
    sheet.getRange(currentRow, 1, 1, 2).setBackground('#e3f2fd');
    currentRow++;
    
    // Summary data
    for (const [key, value] of Object.entries(summaryData)) {
      sheet.getRange(currentRow, 1).setValue(key);
      sheet.getRange(currentRow, 2).setValue(value);
      currentRow++;
    }
    
    // Auto-resize columns
    sheet.autoResizeColumn(1);
    sheet.autoResizeColumn(2);
    
    return currentRow + 1;
  }

  /**
   * Apply styling to Excel report
   */
  applyExcelStyling(spreadsheet, styling) {
    // Apply basic styling to all sheets
    const sheets = spreadsheet.getSheets();
    
    for (const sheet of sheets) {
      const range = sheet.getDataRange();
      if (range.getNumRows() > 0) {
        // Set font family and size
        range.setFontFamily(styling.fontFamily || 'Arial');
        range.setFontSize(styling.fontSize || 11);
      }
    }
  }

  /**
   * Schedule report generation
   */
  scheduleReport(templateId, scheduleConfig) {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const scheduledSheet = ss.getSheetByName(REPORT_CONFIG.SCHEDULED_REPORTS_SHEET_NAME);
      
      if (!scheduledSheet) {
        throw new Error('Scheduled reports sheet not found');
      }
      
      const scheduleId = Utilities.getUuid();
      const nextRun = this.calculateNextRun(scheduleConfig.frequency, scheduleConfig.scheduleTime);
      
      const row = [
        scheduleId,
        templateId,
        scheduleConfig.name,
        scheduleConfig.frequency,
        scheduleConfig.scheduleTime,
        JSON.stringify(scheduleConfig.recipients),
        scheduleConfig.format,
        scheduleConfig.deliveryMethod,
        null, // Last run
        nextRun,
        true, // Is active
        Session.getActiveUser().getEmail()
      ];
      
      scheduledSheet.appendRow(row);
      
      // Create time-based trigger
      this.createScheduleTrigger(scheduleId, scheduleConfig);
      
      return { success: true, scheduleId: scheduleId };
      
    } catch (error) {
      console.error('Failed to schedule report:', error);
      return this.errorHandler.handleError(error, 'schedule_report');
    }
  }

  /**
   * Utility methods
   */
  
  getTemplate(templateId) {
    if (!this.templatesCache) {
      this.loadReportTemplates();
    }
    
    return this.templatesCache.find(template => template['Template ID'] === templateId);
  }

  isCacheValid() {
    if (!this.lastCacheUpdate) return false;
    const cacheAge = new Date() - this.lastCacheUpdate;
    return cacheAge < 30 * 60 * 1000; // 30 minutes
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  calculateNextRun(frequency, scheduleTime) {
    const now = new Date();
    let nextRun = new Date();
    
    switch (frequency) {
      case 'daily':
        nextRun.setHours(parseInt(scheduleTime.split(':')[0]));
        nextRun.setMinutes(parseInt(scheduleTime.split(':')[1]));
        if (nextRun <= now) {
          nextRun.setDate(nextRun.getDate() + 1);
        }
        break;
      case 'weekly':
        // Implementation for weekly scheduling
        nextRun.setDate(nextRun.getDate() + 7);
        break;
      case 'monthly':
        // Implementation for monthly scheduling
        nextRun.setMonth(nextRun.getMonth() + 1);
        break;
    }
    
    return nextRun;
  }

  createScheduleTrigger(scheduleId, scheduleConfig) {
    // Create time-based trigger for scheduled reports
    // This would create appropriate triggers based on the schedule configuration
    console.log(`Creating trigger for schedule ${scheduleId}`);
  }

  logReportGeneration(reportId, template, result, format, options) {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const historySheet = ss.getSheetByName(REPORT_CONFIG.REPORTS_HISTORY_SHEET_NAME);
      
      if (historySheet) {
        const row = [
          reportId,
          template['Template ID'],
          template['Template Name'],
          new Date(),
          Session.getActiveUser().getEmail(),
          format,
          result.size || 0,
          options.deliveryMethod || 'download',
          JSON.stringify(options.recipients || []),
          'Generated',
          result.filePath || '',
          ''
        ];
        
        historySheet.appendRow(row);
      }
    } catch (error) {
      console.error('Failed to log report generation:', error);
    }
  }
}

/**
 * Global functions for report generation
 */

function initializeReportGenerator() {
  const generator = new ReportGenerator();
  return generator.initialize();
}

function generateReport(templateId, parameters, format, options) {
  const generator = new ReportGenerator();
  return generator.generateReport(templateId, parameters, format, options);
}

function getReportTemplates() {
  const generator = new ReportGenerator();
  generator.loadReportTemplates();
  return { success: true, data: generator.templatesCache };
}

function createReportTemplate(templateData) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const templatesSheet = ss.getSheetByName(REPORT_CONFIG.TEMPLATES_SHEET_NAME);
    
    if (!templatesSheet) {
      throw new Error('Report templates sheet not found');
    }
    
    const templateId = Utilities.getUuid();
    const row = [
      templateId,
      templateData.name,
      templateData.reportType,
      templateData.description,
      JSON.stringify(templateData.dataSources),
      JSON.stringify(templateData.formatOptions),
      JSON.stringify(templateData.styling),
      JSON.stringify(templateData.sections),
      new Date(),
      Session.getActiveUser().getEmail(),
      new Date(),
      true
    ];
    
    templatesSheet.appendRow(row);
    
    return { success: true, templateId: templateId };
    
  } catch (error) {
    console.error('Failed to create report template:', error);
    const errorHandler = new ErrorHandler();
    return errorHandler.handleError(error, 'create_report_template');
  }
}

function scheduleReport(templateId, scheduleConfig) {
  const generator = new ReportGenerator();
  return generator.scheduleReport(templateId, scheduleConfig);
}

function getReportHistory(limit = 50) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const historySheet = ss.getSheetByName(REPORT_CONFIG.REPORTS_HISTORY_SHEET_NAME);
    
    if (!historySheet) {
      return { success: true, data: [] };
    }
    
    const data = historySheet.getDataRange().getValues();
    const headers = data[0];
    const history = [];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const record = {};
      headers.forEach((header, index) => {
        record[header] = row[index];
      });
      history.push(record);
    }
    
    // Sort by generated date descending and limit results
    history.sort((a, b) => new Date(b['Generated Date']) - new Date(a['Generated Date']));
    
    return {
      success: true,
      data: history.slice(0, limit)
    };
    
  } catch (error) {
    console.error('Failed to get report history:', error);
    const errorHandler = new ErrorHandler();
    return errorHandler.handleError(error, 'get_report_history');
  }
}